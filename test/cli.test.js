"use strict";

const assert = require("assert/strict");
const fs = require("fs");
const os = require("os");
const path = require("path");
const test = require("node:test");
const { spawnSync } = require("child_process");

const BIN_PATH = path.resolve(__dirname, "..", "bin", "auto-codex.js");

function shellQuote(value) {
  return `'${String(value).replaceAll("'", "'\"'\"'")}'`;
}

function runProcess(cmd, args, { cwd, env, input } = {}) {
  const mergedEnv = {
    ...process.env,
    ...(env || {}),
  };
  delete mergedEnv.NODE_OPTIONS;
  delete mergedEnv.NODE_TEST_CONTEXT;
  delete mergedEnv.NODE_TEST_CHILD;

  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "auto-codex-proc-"));
  const stdoutPath = path.join(tmpDir, "stdout.txt");
  const stderrPath = path.join(tmpDir, "stderr.txt");
  const inputPath = path.join(tmpDir, "stdin.txt");
  if (typeof input === "string") {
    fs.writeFileSync(inputPath, input, "utf8");
  }

  const fullCmd = [cmd, ...args].map(shellQuote).join(" ");
  const redirects = `${fullCmd} > ${shellQuote(stdoutPath)} 2> ${shellQuote(stderrPath)}`;
  const execScript = typeof input === "string"
    ? `${redirects} < ${shellQuote(inputPath)}`
    : redirects;

  const cp = spawnSync("bash", ["-lc", execScript], {
    cwd,
    env: mergedEnv,
    stdio: "inherit",
  });

  const stdout = fs.existsSync(stdoutPath) ? fs.readFileSync(stdoutPath, "utf8") : "";
  const stderr = fs.existsSync(stderrPath) ? fs.readFileSync(stderrPath, "utf8") : "";
  fs.rmSync(tmpDir, { recursive: true, force: true });

  return {
    code: cp.status ?? 1,
    stdout,
    stderr,
  };
}

function runCli(args, options = {}) {
  return runProcess(process.execPath, [BIN_PATH, ...args], options);
}

function runGit(args, repo) {
  const cp = runProcess("git", args, { cwd: repo });
  if (cp.code !== 0) {
    throw new Error(`git ${args.join(" ")} failed\n${cp.stdout}\n${cp.stderr}`);
  }
  return cp;
}

function createRepo(prefix) {
  const repo = fs.mkdtempSync(path.join(os.tmpdir(), prefix));
  runGit(["init", repo], process.cwd());
  runGit(["config", "user.name", "Auto Codex Test"], repo);
  runGit(["config", "user.email", "auto-codex-test@example.com"], repo);
  fs.writeFileSync(path.join(repo, "README.md"), "# Test repo\n", "utf8");
  runGit(["add", "README.md"], repo);
  runGit(["commit", "-m", "init"], repo);
  return repo;
}

function latestRunDir(repo) {
  const runsRoot = path.join(repo, ".auto-codex", "runs");
  const dirs = fs.readdirSync(runsRoot).filter((entry) => entry !== "init").sort();
  assert.ok(dirs.length > 0, "expected at least one run directory");
  return path.join(runsRoot, dirs[dirs.length - 1]);
}

function installCodexStub(repo) {
  const binDir = path.join(repo, ".stub-bin");
  fs.mkdirSync(binDir, { recursive: true });
  const stubPath = path.join(binDir, "codex");
  const logDir = fs.mkdtempSync(path.join(os.tmpdir(), "auto-codex-stub-log-"));
  const logPath = path.join(logDir, "codex-stub.log");
  const source = `#!/usr/bin/env node
"use strict";
const fs = require("fs");
const path = require("path");

function valueAfter(flag) {
  const i = process.argv.indexOf(flag);
  if (i === -1 || i + 1 >= process.argv.length) {
    return "";
  }
  return process.argv[i + 1];
}

const outPath = valueAfter("-o");
const schemaPath = valueAfter("--output-schema");
const prompt = process.argv[process.argv.length - 1] || "";

const logPath = process.env.CODEX_STUB_LOG;
if (logPath) {
  fs.mkdirSync(path.dirname(logPath), { recursive: true });
  fs.appendFileSync(logPath, JSON.stringify({ cwd: process.cwd(), schemaPath, prompt, outPath }) + "\\n");
}

let payload = "ok";
if (schemaPath.endsWith("clarify.schema.json")) {
  payload = JSON.stringify({
    needs_clarification: true,
    questions: [
      {
        id: "Q01",
        type: "single_choice",
        question: "Target site format?",
        required: true,
        allow_free_text: false,
        options: ["Landing page", "Multi-page"],
        rationale: "Sets implementation scope."
      },
      {
        id: "Q02",
        type: "free_text",
        question: "Preferred city?",
        required: false,
        allow_free_text: false,
        options: [],
        rationale: "Optional personalization."
      }
    ]
  }, null, 2);
} else if (schemaPath.endsWith("plan.schema.json")) {
  payload = JSON.stringify({
    title: "Stub plan",
    overview: "Plan generated by codex stub.",
    tasks: [
      {
        id: "T01",
        title: "Build landing shell",
        prompt: "Create the initial landing structure.",
        depends_on: [],
        tags: ["ui"]
      },
      {
        id: "T02",
        title: "Add contact section",
        prompt: "Add contact data and finish UI.",
        depends_on: ["T01"],
        tags: ["ui"]
      }
    ],
    merge_notes: ""
  }, null, 2);
} else if (schemaPath.endsWith("task.schema.json")) {
  const taskMatch = prompt.match(/Task ID:\\s*(T\\d{2})/);
  const taskId = taskMatch ? taskMatch[1] : "T00";
  const fileRel = taskId === "T01" ? "site/index.html" : "site/contact.txt";
  const fullPath = path.join(process.cwd(), fileRel);
  fs.mkdirSync(path.dirname(fullPath), { recursive: true });
  const body = process.env.CODEX_STUB_PLACEHOLDER === "1"
    ? "<p>[city]</p>\\n"
    : "<p>" + taskId + " done</p>\\n";
  fs.writeFileSync(fullPath, body, "utf8");
  payload = JSON.stringify({
    task_id: taskId,
    status: "done",
    summary: taskId + " complete",
    files_changed: [fileRel],
    commands_run: [],
    tests: "",
    notes: ""
  }, null, 2);
} else if (schemaPath.endsWith("merge.schema.json")) {
  payload = JSON.stringify({
    status: "merged",
    summary: "Merged by codex stub",
    conflicts_resolved: [],
    commands_run: [],
    followups: []
  }, null, 2);
}

if (outPath) {
  fs.mkdirSync(path.dirname(outPath), { recursive: true });
  fs.writeFileSync(outPath, payload + "\\n", "utf8");
}
`;
  fs.writeFileSync(stubPath, source, { mode: 0o755 });
  return {
    binDir,
    logPath,
  };
}

function bootstrapRunScaffold(repo, stub) {
  const init = runCli(["init"], {
    cwd: repo,
    env: {
      PATH: `${stub.binDir}:${process.env.PATH}`,
      CODEX_STUB_LOG: stub.logPath,
    },
  });
  assert.equal(init.code, 0, `${init.stderr}\n${init.stdout}`);
  runGit(["add", ".agents", ".auto-codex", ".stub-bin"], repo);
  runGit(["commit", "-m", "bootstrap auto-codex scaffold"], repo);
}

test("plan help includes clarification options", () => {
  const cp = runCli(["plan", "--help"]);
  assert.equal(cp.code, 0, cp.stderr);
  assert.match(cp.stdout, /--no-questions/);
  assert.match(cp.stdout, /--non-interactive/);
  assert.match(cp.stdout, /--max-questions/);
});

test("clean rejects path traversal run ids", () => {
  const repo = createRepo("auto-codex-clean-");
  const cp = runCli(["clean", "../bad"], { cwd: repo });
  assert.notEqual(cp.code, 0, "clean should fail for invalid run_id");
  assert.match(cp.stderr, /invalid run_id/);
});

test("plan stores auto-default clarifications and injects them into planning prompt", () => {
  const repo = createRepo("auto-codex-plan-");
  const stub = installCodexStub(repo);
  const cp = runCli(["plan", "Build a studio site"], {
    cwd: repo,
    env: {
      PATH: `${stub.binDir}:${process.env.PATH}`,
      CODEX_STUB_LOG: stub.logPath,
    },
  });
  assert.equal(cp.code, 0, `${cp.stderr}\n${cp.stdout}`);

  const runDir = latestRunDir(repo);
  const clarifications = JSON.parse(
    fs.readFileSync(path.join(runDir, "clarifications.json"), "utf8"),
  );
  assert.equal(Array.isArray(clarifications.answers), true);
  assert.equal(clarifications.answers.length, 2);
  assert.equal(clarifications.answers[0].source, "auto-default");
  assert.equal(clarifications.answers[0].answer, "Landing page");

  const calls = fs.readFileSync(stub.logPath, "utf8")
    .trim()
    .split("\n")
    .filter(Boolean)
    .map((line) => JSON.parse(line));
  const planCall = calls.find((entry) => String(entry.schemaPath).endsWith("plan.schema.json"));
  assert.ok(planCall, "expected plan call in codex stub log");
  assert.match(planCall.prompt, /User clarifications:/);
  assert.match(planCall.prompt, /Answer: Landing page/);
});

test("run completes end-to-end with non-interactive clarifications", () => {
  const repo = createRepo("auto-codex-run-");
  const stub = installCodexStub(repo);
  bootstrapRunScaffold(repo, stub);
  const cp = runCli(["run", "Build a studio site", "--non-interactive", "-j", "2"], {
    cwd: repo,
    env: {
      PATH: `${stub.binDir}:${process.env.PATH}`,
      CODEX_STUB_LOG: stub.logPath,
    },
  });
  assert.equal(cp.code, 0, `${cp.stderr}\n${cp.stdout}`);

  const runDir = latestRunDir(repo);
  const summary = fs.readFileSync(path.join(runDir, "SUMMARY.md"), "utf8");
  assert.match(summary, /T01/);
  assert.match(summary, /T02/);
  assert.match(summary, /OK\/DONE/);
  assert.equal(fs.existsSync(path.join(repo, "site", "index.html")), true);
  assert.equal(fs.existsSync(path.join(repo, "site", "contact.txt")), true);

  const status = runGit(["status", "--porcelain"], repo);
  assert.equal(status.stdout.trim(), "");
});

test("run fails when placeholder quality check is strict", () => {
  const repo = createRepo("auto-codex-quality-");
  const stub = installCodexStub(repo);
  bootstrapRunScaffold(repo, stub);

  const cfgPath = path.join(repo, ".auto-codex", "config.json");
  fs.writeFileSync(cfgPath, `${JSON.stringify({
    version: 1,
    quality: {
      placeholder_check: "fail",
      placeholder_tokens: [],
    },
    planning: {
      ask_questions: true,
      max_questions: 2,
      non_interactive: true,
    },
    codex: {
      reasoning_effort: "xhigh",
      api_keys_env: [],
    },
  }, null, 2)}\n`, "utf8");
  runGit(["add", ".auto-codex/config.json"], repo);
  runGit(["commit", "-m", "test config"], repo);

  const cp = runCli(["run", "Build a studio site", "--non-interactive"], {
    cwd: repo,
    env: {
      PATH: `${stub.binDir}:${process.env.PATH}`,
      CODEX_STUB_LOG: stub.logPath,
      CODEX_STUB_PLACEHOLDER: "1",
    },
  });
  assert.notEqual(cp.code, 0, "run should fail with strict placeholder check");
  assert.match(cp.stderr, /placeholder quality check found unresolved tokens/);
  assert.match(cp.stderr, /site\/index\.html|site\/contact\.txt/);
});
